# 課題3 レポート
学生番号:35319001　氏名:青木晴喜


## 課題  

以下の2つのアルゴリズムで文字列を検索するプログラムを作成する。  
- 力ずく法
- BM法

1. 使用するデータ  
以下のデータを使用する。ただし、検索対象文字列、検索する文字列は変更しても良い。  
    - StrOriginal: 検索対象データ
    - StrKey: 検索する文字列

2. 必須問題：実装する関数  
本課題では、以下の関数を実装する。C言語の標準ライブラリは使用しないこと。  
    (1) ForceSearch: 力ずく法で文字列を検索する。  
    [入力]  
    - char text[]: 検索対象文字列  
    - char key[]: 検索する文字列  

    [出力]  
    - return値：検索する文字列が出現した場所(ポインタ)。ただし、検索する文字列が見つからない場合はNULL。  

    (2) BMSearch: BM法で文字列を検索する。  
    [入力]  
    - char text[]: 検索対象文字列  
    - char key[]: 検索する文字列  
 
    [出力]  
    - return値：検索する文字列が出現した場所(ポインタ)。ただし、検索する文字列が見つからない場合はNULL。  

3. 補助関数  
なし

## ソースコードの説明

<力ずく法>

l16-18:検索対象文字列において、ヌル文字までの文字数をtext_lenでカウントする。

l20-22:検索する文字列において、ヌル文字までの文字数をkey_lenでカウントする。

l24:検索対象文字列の先頭から順番に検索対象がなくなるまで繰り返す。

l25:検索する文字列の先頭から最後までl26-32の処理を繰り返す。

l26-32:比較場所の文字を比較し、すべて一致したら検索した文字列が出現した場所のポインタを返す。一致しなかった場合は、ループを抜ける。

l36:検索する文字列がなかった場合はNULLを返す。

<BM法>

l65-67:とりあえずずらし表はkeyの長さ(4)で埋める。

l69-71:ずらし表において検索する文字列の分のずらし量を変更。

l75:比較位置indexが文字列の中にある間はそれ以下の処理を繰り返す。

l77:検索する文字列の最後から順にそれ以下の処理を繰り返す。

l79-82:検索したい文字列が最後まで一致したら、一致した場所のポインタを返す。

l88-92:一致しなかったら検索位置をずらし表に基づいてずらす。

l96:一致しなかったらNULLを返す。


## 出力結果

```

Force Search. Find keyword at:wind in my hair.
BM Search. Find keyword at:wind in my hair.

```

## 修正履歴

